# Project Plan: Village Homepage

**Version:** 1.0
**Date:** 2026-01-08
**Generated By:** Codex (GPT-5)

<!-- anchor: project-overview -->
## 1. Project Overview

*   **Goal:** Deliver a compliant, customizable Quarkus SaaS homepage that unifies personalized widgets, classifieds, curated directories, and public profiles while enforcing AI cost controls, privacy mandates, and VillageCompute operational standards.
*   **High-Level Requirements Summary:**
    1. Auth & anonymous merge model with OAuth (Google, Facebook, Apple), GDPR consent, data export/deletion, and shared `users` table per P1/P9.
    2. Homepage widgets rendered via Qute + React islands (gridstack layout, Ant Design components, TS build integration per P8) covering news, weather, stocks, social, quick links, search, and profile/public templates.
    3. Content ingestion with RSS feeds, AI tagging using LangChain4j (P2/P10), weather (Open-Meteo + NWS), stocks (Alpha Vantage), social tokens (Meta Graph API, P5/P13), screenshot capture (P4), and PostGIS-backed search (P6/P11).
    4. Marketplace flows including fees, Stripe payments/refunds (P3), promotions, masked contacts, moderation, listings lifecycle, and Elasticsearch-backed browsing.
    5. Good Sites directory with hierarchical categories, karma-based trust, voting, screenshot service, AI categorization, link health checks, and bubbling algorithms (F13 & P4).
    6. Public profile templates (public_homepage, your_times, your_report) with curated feeds, layout persistence, SEO, analytics, and click tracking (F11 & F14.9).
    7. Cross-cutting observability, delayed job orchestration, feature flags (P7/P14), AI budgeting, rate limiting (F14.2), storage gateway (Cloudflare R2), and CI/CD alignment with infrastructure repo.
*   **Key Assumptions:**
    - LangChain4j remains the abstraction for all AI tasks; swapping providers occurs via config/feature flags.
    - Meta Graph API is the only social connector in v1; architecture allows future adapters without schema rework.
    - Kubernetes, PostgreSQL/PostGIS, Elasticsearch, and Cloudflare R2 are available per sibling repos; terraform/Helm changes happen outside this plan.
    - Directory screenshot retention is indefinite; storage budgets sized accordingly, and CDN handles all public delivery.
    - Feature flag analytics, click tracking, and AI budgets demand 90-day retention windows as stated; ops tooling consumes aggregated tables, not raw partitions.
    - Dev/test share repo artifacts with mainline; local docker-compose includes Postgres, Elasticsearch, Mailpit, MinIO, Jaeger per context instructions.

<!-- anchor: core-architecture -->
## 2. Core Architecture

*   **Architectural Style:** Modular layered monolith on Quarkus 3.26.x with Panache ActiveRecord data access, REST DTO layers, server-rendered Qute templates, React TypeScript islands, and delayed job orchestration mirroring `village-calendar`.
*   **Technology Stack:**
    *   **Frontend:** Qute templates, TypeScript + React 18 islands, gridstack.js for layout drag/drop, Ant Design + @antv visualization suites, esbuild bundling via `frontend-maven-plugin`.
    *   **Backend:** Java 21 LTS, Quarkus extensions (RESTEasy Reactive, OIDC, Scheduler, LangChain4j, S3, Hibernate Search), Panache models, jvppeteer screenshot service, RateLimitService, FeatureFlagService.
    *   **Database:** PostgreSQL 17 with PostGIS extension, JSONB-heavy tables, partitioned audit/click logs, MyBatis migrations, Caffeine-backed 2nd-level cache.
    *   **Messaging/Queues:** Database-backed delayed job queues (DEFAULT/HIGH/LOW/BULK/SCREENSHOT) with handler registry referencing `DelayedJobService` patterns.
    *   **Deployment:** Jib-built OCI images deployed to VillageCompute-managed k3s clusters (beta + production) via infra repo; docker-compose for dev services.
    *   **Other Key Libraries/Tools:** LangChain4j (Claude Sonnet), Stripe SDK, Alpha Vantage client, Open-Meteo/NWS clients, RateLimitService, StorageGateway (Cloudflare R2), Ant Design ConfigProvider, dayjs, @antv/g2plot/s2/l7/g6.
*   **Key Components/Services:**
    - **ExperienceShell:** Qute controllers, gridstack layout orchestration, SEO meta injection, React island mounting.
    - **AuthIdentityService:** OAuth/OIDC bootstrap, anonymous cookie issuance, merge consent audits, GDPR export/deletion orchestrations.
    - **UserPreferenceService:** JSONB layout/preferences store, schema versioning, dark-mode & widget config management.
    - **FeatureFlagService & Cohort Logging:** Implements P7/P14 via rollout percentages, user/session hashing, analytics toggles, audit trails.
    - **RateLimitService:** Tiered quotas for page views, searches, votes, submissions, API calls; logs violations for admin review.
    - **FeedAggregationService:** RSS source CRUD, ingestion jobs, dedupe, AI tag triggers, user interest filtering.
    - **AiTaggingBudgetService & AiTaggingJobHandler:** Batch feed items, fraud heuristics, Good Sites categorization, LangChain4j integration, budget enforcement (P2/P10).
    - **WeatherService, StockService, SocialIntegrationService:** External API adapters with caching, refresh schedules, token management, staleness UX.
    - **MarketplaceService:** Categories, PostGIS search, listing CRUD, promotions, Stripe payment/refunds, moderation, contact relay, image processing.
    - **DirectoryService (Good Sites):** Hierarchical taxonomy, karma system, submissions, screenshot versioning, voting, AI categorization, bubbling, link health.
    - **ProfileService:** Public templates, curated article assignment, SEO metadata, template config persistence, screenshot usage.
    - **ClickTrackingService + Analytics Portal:** Redirect logging, partition rollups, admin dashboards, feature analytics.
    - **StorageGateway:** Cloudflare R2 operations, signed URLs, WebP conversion, retention mapping for marketplace/screenshots/profiles.
    - **JobOrchestrator:** Queue scheduler, handler registry, job telemetry, concurrency controls (SCREENSHOT pool) per P12.
*   **Data Model Overview:** High-level schema covers users/preferences, rss_sources/feed_items, ai_usage_tracking, weather_cache, stock_quotes, social_tokens/posts, marketplace_* tables, payment_refunds, directory_* tables, user_profiles/profile_curated_articles, feature_flags/audit/evaluations, delayed_jobs, link_clicks/click_stats, rate_limit_config/violations, inbound_emails, directory_screenshot_versions. ERDs/diagrams created per Section 2.1.
*   **API Contract Style:** RESTful JSON endpoints documented via OpenAPI v3; `/api` for authenticated user flows, `/admin/api` for privileged analytics, `/track/click` for redirects, `/webhooks/*` for Stripe/email entrypoints, OpenAPI spec iteratively produced (Iteration I2) with DTO-first approach.
*   **Communication Patterns:** Request/response REST for UI interactions; asynchronous workflows (feeds, AI tagging, screenshots, payments, analytics rollups) run through delayed job queues; integration clients share tracing IDs for observability; feature flag evaluations cached per request to avoid inconsistent flows; sequence diagrams cited in Iteration tasks for critical flows.

<!-- anchor: key-architectural-artifacts -->
## 2.1. Key Architectural Artifacts Planned

1. **System Context Diagram (PlantUML):** Visualize actors, external systems (Stripe, Meta, Open-Meteo, Cloudflare R2, LangChain4j), and major components (Iteration I1 Task I1.T2).
2. **Container & Component Diagrams (PlantUML):** Document Quarkus modular monolith layout, worker pods, integration adapters (I1.T2 & I1.T4).
3. **Enterprise ERD (PlantUML/Mermaid):** Capture core tables, relationships, partitioning strategies (I1.T3 with refinements later).
4. **Async Workload Matrix Diagram:** Queue interactions, handler responsibilities, and concurrency constraints (I1.T4).
5. **API Surface Outline & OpenAPI Draft (YAML):** Define DTOs for widgets, marketplace, Good Sites, profiles, analytics (I2.T2, I2.T5).
6. **Sequence Diagrams for Anonymous Merge, Marketplace Listing, Screenshot Pipeline (PlantUML):** Provide reference for compliance-critical flows (I2.T4, I4.T4, I5.T3).
7. **UI/UX Architecture Document with Component Inventory & tokenization (Markdown + Figma linkage) already available from UI partner; iteration tasks reference for alignment.
8. **Ops & Observability Maps:** Logging/metrics/tracing blueprint plus runbook outlines (I6.T4).
9. **Plan Manifest JSON:** Anchor-to-file mapping for downstream agents (post-plan automation task per instructions).

Each artifact uses text-friendly formats (Markdown, PlantUML, YAML) to keep diffs manageable and automation-friendly.

<!-- anchor: directory-structure -->
## 3. Directory Structure

*   **Root Directory:** `village-homepage/`
*   **Structure Definition:**
    ```
    village-homepage/
    ├── .codemachine/                  # Planning artifacts + manifests
    │   └── artifacts/
    │       └── plan/                  # Generated project plan files + manifest
    ├── docs/
    │   ├── diagrams/                  # PlantUML/Mermaid sources (context, ERD, sequence, async matrix)
    │   ├── adr/                       # Architecture decision records (P1-P14 traceability)
    │   ├── ops/                       # Runbooks, job playbooks, AI budget procedures
    │   └── ui-guides/                 # Component contracts, token matrices, onboarding drafts
    ├── api/
    │   └── openapi/                   # YAML specs versioned per iteration
    ├── migrations/                    # MyBatis migrations, seeds (geo data, feature flags)
    ├── src/
    │   ├── main/java/villagecompute/homepage/
    │   │   ├── api/rest/              # REST resources per domain
    │   │   ├── api/types/             # DTO records, versioned by contract
    │   │   ├── config/                # Quarkus config & runtime toggles
    │   │   ├── data/models/           # Panache entities + static finders
    │   │   ├── integration/           # External API clients (weather, stocks, social, AI, Stripe)
    │   │   ├── jobs/                  # Delayed job handlers + schedulers
    │   │   ├── services/              # Domain services (ExperienceShell, Marketplace, Directory, Profile)
    │   │   ├── util/                  # Rate limit buckets, feature hashers, storage helpers
    │   │   └── observability/         # Logging, metrics, tracing helpers
    │   └── main/resources/
    │       ├── META-INF/resources/    # Qute templates, static assets, TypeScript bundles
    │       │   ├── assets/ts/         # React/TS source
    │       │   └── assets/js/         # esbuild output (bundled via plugin)
    │       ├── templates/             # Qute templates (pages, emails)
    │       └── application.properties # Config defaults with %profile overrides
    ├── test/
    │   ├── java/                      # Quarkus tests (REST, Panache, job handlers)
    │   └── resources/                 # Test configs, fixtures
    ├── frontend/                      # Optional workspace for Storybook/esbuild configs
    ├── docker-compose.yml             # Dev services: Postgres/PostGIS, Elasticsearch, Mailpit, MinIO, Jaeger
    ├── pom.xml                        # Maven build incl. frontend plugin, Jib, Spotless
    ├── package.json                   # TS dependencies (gridstack, Ant Design, @antv, React)
    ├── esbuild.config.js              # Build definition for TypeScript/React assets
    ├── README.md                      # Dev setup instructions, policy references, run scripts
    ├── CODEOWNERS                     # Squad ownership per module
    └── Jenkinsfile/GitHub Actions     # CI pipelines hooking into tests, lint, Sonar
    ```
    Key choices: keep doc assets under `docs/` for design artifacts; Mirror package structure mandated in requirements; maintain separation between Qute templates and TS entrypoints; include `frontend/` for Storybook to avoid polluting `src`; embed plan artifacts under `.codemachine/artifacts/plan/` for automation.

<!-- anchor: directives-and-process -->
## 4. Directives & Strict Process

1. **Command Usage Constraint:** Agents must avoid exploratory shell listings per governance notice; rely on targeted file operations and deterministic commands only.
2. **Internal Planning & Atomic Writes:** Before editing, agents must plan mentally, stage entire content in memory, then emit a single write command per file followed by Python-based line-count verification.
3. **Iteration Structure Compliance:** Large-scale classification requires 5–6 iterations with 5–10 tasks each, 140–180 lines per iteration file; tasks must include all required metadata fields and reference anchors for manifest indexing.
4. **Anchoring & Manifestation:** Every heading and task requires a unique `<!-- anchor: ... -->` comment; manifest JSON enumerates anchors, files, and descriptions to unlock autonomous agent retrieval.
5. **Testing & Quality Gates:** All implementation tasks must specify testing expectations (unit, integration, UI/regression, lint), Sonar coverage ≥80%, and policy compliance references.
6. **Cross-Team Coordination:** Reuse standards from sibling repos (roles/permissions, delayed jobs) unless ADR explicitly approves divergence; cite policy IDs (P1–P14, F1–F14) inside task descriptions.
7. **Change Control:** Feature flags, migrations, storage schema updates, or AI budget adjustments mandate ADR/log entries and stakeholder reviews before merge; tasks should call out required approvals.
8. **Security & Privacy:** No task may store secrets in code; encryption, anonymization, and consent flows must be explicit deliverables; verification section reinforces data handling auditable paths.
