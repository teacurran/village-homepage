package villagecompute.homepage.observability;

import io.quarkus.security.identity.SecurityIdentity;
import jakarta.annotation.Priority;
import jakarta.inject.Inject;
import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerRequestFilter;
import jakarta.ws.rs.container.ContainerResponseContext;
import jakarta.ws.rs.container.ContainerResponseFilter;
import jakarta.ws.rs.ext.Provider;
import org.jboss.logging.Logger;

import java.io.IOException;

/**
 * JAX-RS filter that automatically enriches MDC with observability context for all HTTP requests.
 *
 * <p>
 * This filter runs at the start of every HTTP request to populate the Mapped Diagnostic Context (MDC) with fields
 * required by the Observability Implementation Blueprint (Section 3.1). It ensures consistent structured logging across
 * all REST endpoints without requiring manual context management in each resource method.
 *
 * <p>
 * <b>Enrichment Workflow:</b>
 * <ol>
 * <li><b>Request Phase:</b> Populate MDC with trace_id, span_id, user_id/anon_id, and request_origin</li>
 * <li><b>Business Logic:</b> Application code logs events with full context automatically included</li>
 * <li><b>Response Phase:</b> Clear MDC to prevent context leakage across thread reuse</li>
 * </ol>
 *
 * <p>
 * <b>Priority:</b> Runs early in the filter chain (priority 1000) to ensure MDC is populated before any business logic
 * executes, including security filters and interceptors.
 *
 * <p>
 * <b>Integration Points:</b>
 * <ul>
 * <li><b>OpenTelemetry:</b> Automatically extracts trace_id/span_id from W3C Trace Context headers</li>
 * <li><b>Security:</b> Reads user_id from Quarkus {@link SecurityIdentity} after OIDC authentication</li>
 * <li><b>Feature Flags:</b> Future integration will read active flags from FeatureFlagService (not yet
 * implemented)</li>
 * <li><b>Rate Limiting:</b> Future integration will capture rate limit bucket from RateLimiterService</li>
 * </ul>
 *
 * <p>
 * <b>Anonymous Sessions:</b> For unauthenticated requests, the filter checks for an {@code anon_id} cookie (UUID) and
 * populates MDC accordingly. If no cookie exists, the anon_id field is omitted (frontend will create cookie on first
 * interaction).
 *
 * <p>
 * <b>Example Log Output (JSON):</b>
 *
 * <pre>
 * {
 *   "timestamp": "2025-01-08T22:45:12.345Z",
 *   "level": "INFO",
 *   "message": "Widget created successfully",
 *   "trace_id": "4bf92f3577b34da6a3ce929d0e0e4736",
 *   "span_id": "00f067aa0ba902b7",
 *   "user_id": "42",
 *   "request_origin": "/api/widgets",
 *   "feature_flags": "stocks_widget,social_integration",
 *   "service.name": "village-homepage"
 * }
 * </pre>
 *
 * @see LoggingConfig for MDC field definitions and utility methods
 */
@Provider
@Priority(1000)
public class LoggingEnricher implements ContainerRequestFilter, ContainerResponseFilter {

    private static final Logger LOG = Logger.getLogger(LoggingEnricher.class);

    /**
     * Cookie name for anonymous session tracking. Generated by frontend on first visit, stored as HttpOnly cookie.
     */
    private static final String ANON_ID_COOKIE = "anon_id";

    @Inject
    SecurityIdentity securityIdentity;

    /**
     * Enriches MDC at the start of every HTTP request.
     *
     * <p>
     * This method runs before business logic executes, ensuring all downstream logs contain full observability context.
     * It handles both authenticated and anonymous sessions gracefully.
     *
     * <p>
     * <b>Future Enhancements:</b>
     * <ul>
     * <li>Inject {@code FeatureFlagService} to populate {@code feature_flags} field</li>
     * <li>Inject {@code RateLimiterService} to populate {@code rate_limit_bucket} field</li>
     * <li>Support request-scoped trace baggage for cross-service correlation</li>
     * </ul>
     *
     * @param requestContext
     *            JAX-RS request context providing headers, cookies, and URI
     */
    @Override
    public void filter(ContainerRequestContext requestContext) throws IOException {
        // 1. Enrich with OpenTelemetry trace context (trace_id, span_id)
        LoggingConfig.enrichWithTraceContext();

        // 2. Set request origin (HTTP method + path)
        String requestOrigin = requestContext.getMethod() + " " + requestContext.getUriInfo().getPath();
        LoggingConfig.setRequestOrigin(requestOrigin);

        // 3. Set user ID or anonymous ID based on authentication state
        if (securityIdentity != null && !securityIdentity.isAnonymous()) {
            // Authenticated user: extract user_id from security principal
            // Future implementation will use User.id from authenticated principal
            // For now, use principal name as placeholder (will be numeric ID later)
            String principalName = securityIdentity.getPrincipal().getName();
            try {
                Long userId = Long.parseLong(principalName);
                LoggingConfig.setUserId(userId);
            } catch (NumberFormatException e) {
                // Principal is not numeric (e.g., email from OIDC). Skip user_id until User entity exists
                LOG.debugf("Non-numeric principal name: %s. User entity integration pending.", principalName);
            }
        } else {
            // Anonymous user: extract anon_id from cookie if present
            jakarta.ws.rs.core.Cookie anonCookie = requestContext.getCookies().get(ANON_ID_COOKIE);
            if (anonCookie != null) {
                LoggingConfig.setAnonId(anonCookie.getValue());
            }
        }

        // 4. TODO: Set feature flags (requires FeatureFlagService integration)
        // Example: LoggingConfig.setFeatureFlags(featureFlagService.getActiveFlags(userId/anonId));

        // 5. TODO: Set rate limit bucket (requires RateLimiterService integration)
        // Example: LoggingConfig.setRateLimitBucket(rateLimiter.getBucketKey(userId/anonId, actionType));

        LOG.debugf("MDC enriched for request: %s", requestOrigin);
    }

    /**
     * Clears MDC at the end of every HTTP request to prevent context leakage.
     *
     * <p>
     * <b>Critical:</b> Quarkus uses thread pooling, meaning the same thread may serve multiple requests sequentially.
     * Failing to clear MDC would cause logs from one request to contain stale data from previous requests.
     *
     * <p>
     * This method runs after the response is written but before the thread is returned to the pool.
     *
     * @param requestContext
     *            JAX-RS request context (unused)
     * @param responseContext
     *            JAX-RS response context (unused)
     */
    @Override
    public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext)
            throws IOException {
        // Clear MDC to prevent context leakage across thread reuse
        LoggingConfig.clearMDC();
        LOG.trace("MDC cleared after response");
    }
}
